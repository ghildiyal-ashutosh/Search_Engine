Snippets for the query:  Q14
************************
Total Hits:  34
************************

************************
Document:  CACM-1974.html
************************
************************
Document:  CACM-1737.html
************************
************************
Document:  CACM-1886.html
************************


generation of optimal code for expressions via factorization

given a set of expressions which are to be
compiled, methods are presented for increasing the 
efficiency of the object code produced by first factoring
the expressions, i.e. finding a set of subexpressions 
each of which occurs in two or more other expressions
or subexpressions.  once all the factors have been 
ascertained, a sequencing procedure is applied which
orders the factors and expressions such that all 
information is computed in the correct sequence and factors
need be retained in memory a minimal amount 
of time.  an assignment algorithm is then executed in
order to minimize the total number of temporary 
storage cells required to hold the results of evaluating
the factors.  in order to make these techniques 
computationally feasible, heuristic procedures are
applied, and hence global optimal results are not 
necessarily generated.  the factorization algorithms
are also applicable to the problem of factoring 
boolean switching expressions and of factoring polynomials
encountered in symbol manipulating systems.

cacm june, 1969

breuer, m. a.

factorization algorithms, code optimization, sequencing
of operations, 
************************

************************
Document:  CACM-2133.html
************************
************************
Document:  CACM-2344.html
************************
************************
Document:  CACM-1676.html
************************
************************
Document:  CACM-2477.html
************************
************************
Document:  CACM-1961.html
************************
************************
Document:  CACM-2943.html
************************


lucid, a nonprocedural language with iteration

lucid is a formal system in which programs
can be written and proofs of programs carried out. 
 the proofs are particularly easy to follow and straightforward
to produce because the statements in 
a lucid program are simply axioms from which the proof
proceeds by (almost) conventional logical reasoning, 
with the help of a few axioms and rules of inference
for the special lucid functions.  as a programming 
language, lucid is unconventional because, among other
things, the order of statements is irrelevant 
and assignment statements are equations.  nevertheless,
lucid programs need not look much different than 
iterative programs in a conventional structured programming
language using assignment and conditional 
statements and loops.

cacm july, 1977

ashcrof, 
************************

************************
Document:  CACM-1750.html
************************


considerations in the design of a multiple
computer system with extended core storage

the use of large quantities of addressable
(but not executable) fast random access memory to 
heighten the multiprogramming performance of a multicomputer system
is discussed.  the general design 
of the hardware arrangement and the software components
and functions of such a system are based on a 
planned configuration of dual cdc 6600's that share one
million words of extended core storage.  in the 
generalization of such a design, special emphasis is
placed on estimating 
************************

************************
Document:  CACM-1795.html
************************
************************
Document:  CACM-3020.html
************************
************************
Document:  CACM-2883.html
************************
************************
Document:  CACM-0104.html
************************
************************
Document:  CACM-3069.html
************************


a practical interprocedural data flow analysis algorithm

a new interprocedural  data flow analysis algorithm
is presented and analyzed.  the algorithm 
associates with each procedure in a program information
about which variables may be modified, which 
may be used, and which are possibly preserved by a call
on the procedure, and all of its subcalls.  the 
algorithm is sufficiently powerful to be used on recursive
programs and to deal with the sharing of variables 
which arises through reference parameters.  the algorithm
is unique in that it can compute all of this 
information in a single pass, not requiring a prepass to
compute calling relationships or sharing patterns. 
 the algorithm is asymptotically optimal in time complexity.
 it has been implemented and is practical 
even on programs which are quite large.

cacm september, 1978

barth, j.

data flow analysis, global flow analysis, optimization,
side effects, relations, 
************************

************************
Document:  CACM-3156.html
************************
************************
Document:  CACM-1564.html
************************
************************
Document:  CACM-2964.html
************************
************************
Document:  CACM-2253.html
************************
************************
Document:  CACM-1809.html
************************
************************
Document:  CACM-2388.html
************************


optimizing binary trees grown with a sorting algorithm

items can be retrieved from binary trees grown
with a form of the algorithm quicksort in an 
average time proportional to log n, where n is the number
of items in the tree.  the binary trees grown 
by this algorithm sometimes have some branches longer
than others; therefore, it is possible to reduce 
the average retrieval time by restructuring the tree to
make the branches as uniform in length as possible. 
 an algorithm to do this is presented.  the use of this
algorithm is discussed, and it is compared with 
another which restructures the tree after each new item is added.

cacm february, 1972

martin, w. a.
ness, d. n.

retrieving information from binary trees, global
and local optimization, sorting, recursion

************************

************************
Document:  CACM-2716.html
************************


optimizing the performance of a relational algebra database interface

an approach for implementing a "smart" interface
to support a relational view of data is proposed. 
 the basic idea is to employ automatic programming techniques
so that the interface analyzes and efficiently 
refines the high level query specification supplied by
the user.  a relational algebra interface, called 
squiral, which was designed using this approach, is described
in detail. squiral seeks to minimize query 
response time and space utilization by: (1) performing
global query optimization, (2) exploiting disjoint 
************************

************************
Document:  CACM-2081.html
************************


some complete calculi for matrices

a matrix calculus is introduced with the intention of developing data structures
suitable for a high level algorithmic language for mathematical programming.  
the paper investigates how the special structure of matrices can be described
and utilized for efficient computing by saving memory space and
superfluous operations.  sequences of matrices (and sequences of sequences
of matrices) are considered, and matrix operators areext
ended to sequence operators and cumulative operators.  algorithms
are given which use symbol manipulation of matrix expressions so
as to find the forms best suited 
************************

************************
Document:  CACM-1910.html
************************
************************
Document:  CACM-2495.html
************************
************************
Document:  CACM-1658.html
************************
************************
Document:  CACM-1410.html
************************
************************
Document:  CACM-2699.html
************************
************************
Document:  CACM-2321.html
************************
************************
Document:  CACM-1191.html
************************
************************
Document:  CACM-2940.html
************************


abstraction and verification in alphard: defining
and specifying iteration and generators

the alphard "form" provides the programmer with
a great deal of control over the implementation 
of abstract data types.  in this paper the abstraction techniques
are extended from simple data representation 
and function definition to the iteration statement, the
most important poin t of interaction between data 
and the control structure of the language itself.  a
means of specializing alphard's loops to operate 
on abstract 
************************
 to operate 
on abstract entities without explicit dependence on the
representation of those entities is in troduced. 
 specification and verification techniques that allow
the properties of the generators for such iterations 
to be expressed in the form of proof rules are developed.
 results are obtained that for common special 
cases of these loops are essentially identical 
************************

************************
Document:  CACM-2451.html
************************
************************
Document:  CACM-2423.html
************************
************************
Document:  CACM-0243.html
************************
************************
Document:  CACM-2231.html
************************
************************
Document:  CACM-1643.html
************************
************************
Document:  CACM-3118.html
************************
************************
Document:  CACM-2188.html
************************


an approach to the optimum design of computer graphics systems

display system designers are faced with the
difficult task of selecting major subsystems in 
an intelligent way.  each subsystem is chosen from large
numbers of alternatives; the selection is based 
on considerations such as system response time, system
cost, and the distribution of data storage and 
processing between the graphics processor and its supporting
data processing system.  the work reported 
here develops an objective, quantitative design procedure
and helps give a better understanding of now 
to  configure display systems.  this is accomplished by
means of a mathematical model of a computer driven 
graphics system.  the parameters of the model are functions
of the capabilities of the graphics hardware 
and of the computational requirements of the graphics application.
 the model can be analyzed using numerical 
queueing analysis or simulation to obtain an average
response time prediction.  by combining the model 
with an optimization, the best graphics system configuration,
subject to a cost constraint, is found 
for several applications.  the optimum configurations
are in turn used to find general display system 
************************

************************
Document:  CACM-2015.html
************************
************************
Document:  CACM-2433.html
************************
************************
Document:  CACM-2314.html
************************
************************
Document:  CACM-2134.html
************************
************************
Document:  CACM-2722.html
************************
************************
Document:  CACM-2411.html
************************
************************
Document:  CACM-2000.html
************************
************************
Document:  CACM-2685.html
************************
************************
Document:  CACM-1951.html
************************
************************
Document:  CACM-1906.html
************************
************************
Document:  CACM-3002.html
************************
************************
Document:  CACM-1710.html
************************


asp-a ring implemented associative structure package

asp is a general purpose associative data
structure package in which an arbitrary number of 
data items and an arbitrary number of the relationships
between these data items may be represented. 
 a special picture language is described which has proved
very useful for drawing asp structures on paper. 
 asp structures are built and manipulated by means
of a series of macro calls, which are outlined in 
the appendix.  emphasis is on the philosophy 
************************

************************
Document:  CACM-2880.html
************************
************************
Document:  CACM-2701.html
************************


a fast and usually linear algorithm for global
flow analysis (abstract only--complete paper jacm 
23,1 january, 1976)

a new algorithm for global flow analysis on
reducible graphs is presented. the algorithm is 
shown to treat a very general class of function spaces.
 for a graph of e edges, the algorithm has a 
worst case time bound of o(e log e) function operations.
 it is also shown that in programming terms, 
the number of operations is proportional to e plus the
number of exits from program loops.  consequently 
a restriction to one-entry one-exit control structures
linearity.  the algorithm can be extended to yet 
larger classes of function spaces and graphs by relaxing
the time bound.  examples are given of code 
improvement problems which can be solved using the algorithm.

cacm december, 1975

graham, s. l.
wegman, m.

global flow analysis, data flow, code optimization,
common subexpression 
************************

************************
Document:  CACM-3018.html
************************
************************
Document:  CACM-1807.html
************************


optimization of expressions in fortran

a method of optimizing the computation of
arithmetic and indexing expressions of a fortran 
program is presented.  the method is based on a linear
analysis of the definition points of the variables 
and the branching and do loop structure of the program.
 the objectives of the processing are (1) to 
eliminate redundant calculations when references are
made to common subexpression values, (2) to remove 
invariant calculations from do loops, (3) to efficiently

************************
, (3) to efficiently
compute subscripts containing do iteration variables, 
and (4) to provide efficient index register usage.  the
method presented requires at least a three-pass 
compiler, the second of which is scanned backward.  it
has been used in the development of several fortran 
compilers that have proved to produce excellent object
code without significantly reducing the compilation 
speed.

cacm december, 1969

busam, v. a.
england, d. e.

fortran, optimization, expressions, compilers,
compilation, subscripts, register allocation, do 
loops, common subexpressions, 
************************

************************
Document:  CACM-2570.html
************************
************************
Document:  CACM-2195.html
************************


on the optimal detection of curves in noisy pictures

a technique for recognizing systems of lines
is presented.  in this technique the heuristic 
of the problem is not embedded in the recognition algorithm
but is expressed in a figure of merit.   
a multistage decision process is then able to recognize
in the input picture the optimal system of lines 
according to the given figure of merit.  due to the
global approach, greater flexibility and adequacy 
in the particular problem is achieved.  the relation
between the structure of the figure of merit and 
the complexity of the optimization process is then discussed.

************************
 process is then discussed.
 the method described is suitable for parallel 
processing because the operations relative to each
state can be computed in parallel, and the number
of stages is equal to the length n of the curves (or
to log2 n if the approximate method is used).

cacm may, 1971

montanari, u.

picture processing, picture recognition, picture
description, curve detection, line detection, 
edge detection,optimal detection, heuristic methods,
global recognition, parallel processing, dynamic 
programming, interaction graph, secondary optimization problem

3.63 3.66 5.42

************************

************************
Document:  CACM-1231.html
************************
************************
Document:  CACM-1195.html
************************
************************
Document:  CACM-2903.html
************************
************************
Document:  CACM-3132.html
************************
************************
Document:  CACM-1719.html
************************
************************
Document:  CACM-2851.html
************************


formal verification of parallel programs

two formal models for parallel computation
are presented: an abstract conceptual model and 
a parallel-program model.  the former model does not
distinguish between control and data states.  the 
latter model includes the capability for the representation
of an infinite set of control states by allowing 
there to be arbitrarily many instruction pointers (or
processes) executing the program.  an induction 
principle is presented which treats the control and
data state sets on the same ground.  through the 
use of "place variables," it is observed that certain
correctness conditions can be expressed without 
enumeration of the set of all possible control states.
 examples are presented in which the induction 
principle is used to demonstrate proofs of mutual exclusion.
 it is shown that assertions-oriented proof 
methods are special cases of the induction principle.
a special case of the assertions method, which 
is called parallel place assertions, is shown to be
incomplete.  a formalization of "deadlock" is then 
presented. the concept of a "norm" is introduced, which
yields an extension, to the deadlock problem, 
of floyd's technique for proving termination.  also discussed
is an extension of the program model which 
allows each process to have its own local variables
and permits shared global variables.  correctness 
************************

************************
Document:  CACM-2290.html
************************
************************
Document:  CACM-2812.html
************************
************************
Document:  CACM-2065.html
************************


a programming system for the on-line analysis of biomedical images

a preliminary description of the software for a computer-display
system is given with special emphasis on the  man-machine 
************************

************************
Document:  CACM-2396.html
************************


muse: a model to understand simple english

muse is a computer model for natural language
processing, based on a semantic memory network 
like that of quillian's tlc.  muse, from a model to understand
simple english, processes english sentences 
of unrestricted content but somewhat restricted format.
 the model first applies syntactic analysis to 
eliminate some interpretations and then employs a simplified
semantic intersection procedure to find 
a valid interpretation of the input.  while the semantic
processing is similar to tlc's, the syntactic 
component includes the early use of parse trees and special
purpose rules.  the 
************************

************************
Document:  CACM-3054.html
************************


implementing quicksort programs

this paper is a practical study of how to
implement the quicksort sorting algorithm and its 
best variants on real computers, including how to apply
various code optimization techniques.  a detailed 
implementation combining the most effective improvements
to quicksort is given, along with a discussion 
of how to implement it in assembly language.  analytic
results describing the performance of the programs 
are summarized.  a variety of special situations are considered

************************

************************
Document:  CACM-2953.html
************************
************************
Document:  CACM-2836.html
************************
************************
Document:  CACM-2142.html
************************


reconstruction of pictures from their projections

there are situations in the natural sciences
and medicine (e.g. in electron microscopy and 
x-ray photography) in which it is desirable to estimate the
gray levels of a digital picture at the individual 
points from the sums of the gray levels along straight
lines (projections) at a few angles.  usually, 
in such situations, the picture is far from determined
and the problem is to find the "most representative" 
picture.  three algorithms are described (all using
monte carlo methods) which were designed to solve 
this problem.  the algorithms are applicable in a large
and varied number of fields.  the most important 
uses may be the reconstruction of possibly asymmetric particles
from electron micrographs and three-dimensional 
x-ray analysis.

cacm december, 1971

gordon,r.
herman, g. t.

approximation, biomedical image processing, efficient
encoding, image processing, linear programming, 
mathematical programming, monte carlo techniques, optimization,
picture compression, 
************************

************************
Document:  CACM-2897.html
************************


a case study of a new code generation technique for compilers

recent developments in optimizing techniques
have allowed a new design for compilers to emerge. 
 such a compiler translates the parsed source code into
lower level code by a sequence of steps.  each 
step expands higher level statements into blocks of
lower level code and then performs optimizations 
on the result.  each statement has only one possible
expansion-the task of tailoring this code to take 
advantage of any special cases is done by the 
************************

************************
Document:  CACM-2464.html
************************
************************
Document:  CACM-2923.html
************************


high-level data flow analysis

in contrast to the predominant use of low-level
in termediate text, high-level data flow analysis 
deals with programs essentially at source level and
exploits the control flow information implicit in 
the parse tree.  the need for high-level flow analysis
arises from several aspects of recent work on 
advanced methods of program certification and optimization.
 this paper proposes a simple general method 
of high-level data flow analysis that allows free use
of escape and jump statements, avoids large graphs 
when compiling large programs, facilitates updating of
data flow information to reflect program changes, 
and derives new global information helpful 
************************

************************
Document:  CACM-3053.html
************************
************************
Document:  CACM-2680.html
************************
************************
Document:  CACM-3080.html
************************
************************
Document:  CACM-2827.html
************************


a parametric algorithm for drawing pictures
of solid objects composed of quadric surfaces

an algorithm for drawing pictures of three-dimensional
objects, with surfaces made up of patches 
of quadric surfaces, is described.  the emphasis of
this algorithm is on calculating the intersections 
of quadric surfaces. a parameterization scheme is used.
 each quadric surface intersection curve (qsic) 
is represented as a set of coefficients and parameter
limits.  each value of the parameter represents 
at most two points, and these may easily be distinguished.
 this scheme can find the coordinates of points 
************************

************************
Document:  CACM-0695.html
************************


use of the disk file on stretch

the paper begins by briefly describing the
stretch (ibm 7030) computer with special emphasis 
given to the organization 
************************

************************
Document:  CACM-1808.html
************************


advanced cryptographic techniques for computers

cryptographic techniques which can be used to
maintain the confidentiality of information processed 
by computers are dealt with.  special emphasis is paid
to the unique 
************************

************************
Document:  CACM-2611.html
************************
************************
Document:  CACM-0820.html
************************
************************
Document:  CACM-2904.html
************************
************************
Document:  CACM-2929.html
************************
************************
Document:  CACM-1947.html
************************


object code optimization

methods of analyzing the control flow and data
flow of programs during compilation are applied 
to transforming the program to improve object time efficiency.
 dominance relationships, indicating which 
statements are necessarily executed before others, are
used to do global common expression elimination 
************************

************************
Document:  CACM-2835.html
************************
************************
Document:  CACM-2715.html
************************


implementation of a structured english query language

the relational model of data, the xrm relational
memory system, and the sequel language have 
been covered in previous papers and are reviewed. 
sequel is a relational data sublanguages intended 
for the ad hoc interactive problem solving by non-computer
specialists.  a version of sequel that has 
been implemented in a prototype interpreter is described.
 the interpreter is designed to minimize the 
data accessing operations required to respond to an arbitrary
query.  the optimization algorithms designed 
************************

************************
Document:  CACM-1459.html
************************
************************
Document:  CACM-3125.html
************************


global optimization by suppression of partial 
************************
 by suppression of partial redundancies

the elimination of redundant computations and the moving of invariant
computations out of loops are often done separately, with invariants 
moved outward loop by loop.  we propose to do both at once and
to move each expression directly to the entrance of the outermost
loop in which it is invariant.  this is done by solving a more
general problem, i.e. the elimination of computations performed
twice on a given execution path.  such computations are termed partially
redundant.  moreover, the algorithm does not require any graphical
information or restrictions on the shape of the program graph.
testing this algorithm has shown that its execution cost is nearly
linear with the size of the program, and that it leads
to a smaller optimizer that requires less execution time.

cacm february, 1979

morel, e.
renvoise, c.

optimizer, optimization, compiler, compilation,

************************

************************
Document:  CACM-2969.html
************************
************************
Document:  CACM-2877.html
************************


a program data flow analysis procedure

the global data relationships in a program
can be exposed and codified by the static analysis 
methods described in this paper.  a procedure is given
which determines all the definitions which can
possibly "reach" each node of the control flow graph
of the program and all the definitions that are 
"live" on each edge of the graph.  the procedure uses
an "interval" ordered edge listing data structure 
and handles reducible and irreducible graphs indistinguishably.

cacm march, 1976

allen, j. e.
cocke, j.

program optimization, data flow analysis,

************************

************************
Document:  CACM-2537.html
************************
************************
Document:  CACM-1223.html
************************


high speed compilation of efficient object code

a three-pass compiler with the following properties
is briefly described:  the last two passes 
scan an intermediate language produced by the preceding
pass in essentially the reverse of the order 
in which it was generated, so that the first pass is the
only one which hasto read the bulky problem-oriented 
input.  the double scan, one in either direction, performed
by the first two passes, allows the compiler 
to remove locally constant expressions and recursively
calculable expressions from loops and to do the 
important part of common subexpression recognition.
 optimization such as the effective 
************************

************************
Document:  CACM-2944.html
************************


shifting garbage collection overhead to compile time

this paper discusses techniques which enable automatic
storage reclamation overhead to be partially 
shifted to compile time.  the paper assumes a transaction
oriented collection scheme, as proposed by 
deutsch and bobrow, the necessary features of which are
summarized.  implementing the described optimizations 
requires global flow analysis to be 
************************
 flow analysis to be performed on the
source program.  it is shown that at compile time 
certain program actions that affect the reference counts
of cells can be deduced.  this information is 
used to find actions that cancel when the code is executed
and those that can be grouped to achieve improved 
efficiency.

cacm july, 1977

barth, j. m.

garbage collection, global flow analysis, list processing,
optimization, reference counts, storage 
************************

************************
Document:  CACM-2579.html
************************
************************
Document:  CACM-2858.html
************************
************************
Document:  CACM-0693.html
************************
************************
Document:  CACM-2616.html
************************
************************
Document:  CACM-0089.html
************************
************************
Document:  CACM-3157.html
************************
************************
Document:  CACM-2574.html
************************
