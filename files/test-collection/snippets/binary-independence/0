Snippets for the query:  Q0
************************
Total Hits:  15
************************

************************
Document:  CACM-1974.html
************************
************************
Document:  CACM-2666.html
************************


on lions' counter example for gotlieb's method
for the construction of school timetables

the timetable problem is an essentially discrete
problem. although the discrete problem may 
have no feasible solution, there may exist a solution
to the equivalent 
************************

************************
Document:  CACM-0586.html
************************
************************
Document:  CACM-0142.html
************************
************************
Document:  CACM-1138.html
************************
************************
Document:  CACM-3191.html
************************
************************
Document:  CACM-2889.html
************************
************************
Document:  CACM-1442.html
************************
************************
Document:  CACM-1469.html
************************
************************
Document:  CACM-0460.html
************************
************************
Document:  CACM-1090.html
************************
************************
Document:  CACM-1439.html
************************
************************
Document:  CACM-1179.html
************************


pufft-the purdue university fast fortran translator

a core resident, compile-and-go system designed
for the ibm 7090/7094 computer is 
************************
 7090/7094 computer is described. 
 in little more than half of the 32k word core memory
pufft provides a monitor for job sequencing, a 
translator for the full fortran iv language, the fortran
subroutine library, an input--output system 
for use at compile time and at execute time, 
************************
 and at execute time, and a rather
elaborate diagnostic message writing routine. 
 batches of small- and medium-sized fortran iv source
language programs are processed at very high speeds. 
 language compatibility has been maintained so that
programs may be debugged in the pufft system and 
then recompiled 
************************

************************
Document:  CACM-2352.html
************************
************************
Document:  CACM-2676.html
************************
************************
Document:  CACM-0672.html
************************
************************
Document:  CACM-1046.html
************************


a compiler-building system developed by brooker and morris

in a number of articles published during the

************************

************************
Document:  CACM-0021.html
************************
************************
Document:  CACM-2639.html
************************
************************
Document:  CACM-1453.html
************************
************************
Document:  CACM-0963.html
************************
************************
Document:  CACM-0076.html
************************
************************
Document:  CACM-3124.html
************************
************************
Document:  CACM-0475.html
************************
************************
Document:  CACM-0582.html
************************
************************
Document:  CACM-0516.html
************************
************************
Document:  CACM-1235.html
************************
************************
Document:  CACM-2573.html
************************
************************
Document:  CACM-3144.html
************************
************************
Document:  CACM-1390.html
************************
************************
Document:  CACM-0895.html
************************
************************
Document:  CACM-1996.html
************************
************************
Document:  CACM-1008.html
************************
************************
Document:  CACM-0430.html
************************
************************
Document:  CACM-0810.html
************************
************************
Document:  CACM-1244.html
************************
************************
Document:  CACM-0275.html
************************
************************
Document:  CACM-2306.html
************************
************************
Document:  CACM-2842.html
************************
************************
Document:  CACM-2219.html
************************


a policy-driven scheduler for a time-sharing system

the service received 
************************


the service received by a process from a time-sharing
operating system can be characterized 
************************
 can be characterized 
by a resource count sum{w[i]r[ij]} where r[ij] is the
number of units of service received by process 
i from resource i and w[i] is the cost per unit of the
service.  each class of users can be characterized 
by a policy function which specifies the amount of service
a user who belongs to this class should receive 
as a function of time.  priority changes dynamically
as a function of the difference between the service 
promised to the user by the policy function and the service
he actually receives.  a scheduling and swapping 
algorithm which keeps the resource count of each process
above its policy function will provide the specified 
level of service.  overhead can be reduced by avoiding
swaps of process which have received at least 
his level of service.  the algorithm has been implemented
in a general purpose operating system, and 
it has provided 
************************
, and 
it has provided significantly better service to interactive
and to batch jobs than the previous scheduler.

cacm february, 1971

bernstein, a. j.
sharp, j. c.

scheduler, time-sharing, operating system,
resource allocation 
************************

************************
Document:  CACM-1297.html
************************
************************
Document:  CACM-1256.html
************************
************************
Document:  CACM-3137.html
************************


a methodology for the design of distributed information systems

a macro model of a distributed information system in presented.  the model
describes the major costs of using an information
system from the perspective of the end-user.  the making evident the effect of
various design and operating parameters on overall 
************************

************************
Document:  CACM-1425.html
************************
************************
Document:  CACM-0434.html
************************
************************
Document:  CACM-0150.html
************************
************************
Document:  CACM-0584.html
************************
************************
Document:  CACM-1283.html
************************
************************
Document:  CACM-2119.html
************************
************************
Document:  CACM-1754.html
************************
************************
Document:  CACM-0015.html
************************
************************
Document:  CACM-0469.html
************************
************************
Document:  CACM-0030.html
************************
************************
Document:  CACM-1230.html
************************
************************
Document:  CACM-3118.html
************************
************************
Document:  CACM-0118.html
************************
************************
Document:  CACM-0306.html
************************
************************
Document:  CACM-0248.html
************************
************************
Document:  CACM-1415.html
************************
************************
Document:  CACM-0612.html
************************
************************
Document:  CACM-2651.html
************************
************************
Document:  CACM-2691.html
************************
************************
Document:  CACM-0364.html
************************
************************
Document:  CACM-2925.html
************************
************************
Document:  CACM-0556.html
************************
************************
Document:  CACM-0591.html
************************
************************
Document:  CACM-1427.html
************************
************************
Document:  CACM-1801.html
************************
************************
Document:  CACM-2151.html
************************


user program measurement in a time-shared environment

a general discussion of the measurement of
software systems is followed by a description of 
a hardware and software scheme for measuring user programs
in a time-shared environment.  the tx-2 computer 
at mit lincoln laboratory was used for the implementation
of such a system and the characteristics of 
this implementation are reported.  a scenario showing
the system in use is presented.  finally, it is 
shown how other time-sharing systems may provide similar measuring facilities.

cacm october, 1971

nemeth, a. g.
rovner, p. d.

operating systems, multiprogramming systems, time-sharing
systems, software measurement, user program 
measurement, measurement technology, tx-2 computer,
virtual computers, performance improvement

************************

************************
Document:  CACM-0026.html
************************
************************
Document:  CACM-1984.html
************************
************************
Document:  CACM-2374.html
************************


a study of storage partitioning using a mathematical model of locality

both fixed and dynamic storage partitioning
procedures are examined for use in multiprogramming 
systems.  the storage requirement of programs is modeled
as a stationary gaussian process.  experiments 
justifying this model are described.  by means of this
model dynamic storage partitioning is shown to 
provide substantial increases in storage utilization
and operating efficiency over fixed partitioning. 

cacm march, 1972

coffman jr., e. g.
ryan jr., t. a.

storage partitioning, memory management, dynamic
storage allocation, space sharing, multiprogrammed 
storage, 
************************

************************
Document:  CACM-0074.html
************************
************************
Document:  CACM-3134.html
************************
************************
Document:  CACM-2670.html
************************
************************
Document:  CACM-2758.html
************************
************************
Document:  CACM-1873.html
************************
************************
Document:  CACM-1497.html
************************
************************
Document:  CACM-1454.html
************************
************************
Document:  CACM-3002.html
************************


a record and file partitioning model

one of the main objectives in the design of
a file system is the reduction of storage and data 
transfer costs.  this paper presents a model in which
several  requests access the file system, and each 
request requires information from one or more variable
length data-items.  the probabilities of access 
and the distribution of each data-item's length are assumed
to be known, and to be mutually independent. 
the file system uses one or more storage devices, and
each record may be partitioned into subrecords 
that are stored on different devices.  one of the subrecords
is designated as the primary record; when 
a request for a record is made, the primary record is
first accessed, and other subrecords are accessed 
only if the pertinent information is not stored in the
primary record.  the model that is presented in 
this paper, both as a nonlinear programming model and
a mixed integer programming model, is a very general 
one; several types of file systems may be derived from
it by an appropriate selection of its parameters. 
 this model has already been used in the optimization of
library routines' storage at a large scale operating 
system.

cacm january, 
************************

************************
Document:  CACM-2083.html
************************


creation and control of internal data bases
under a fortran programming environment

a method is described for the definition of a user's common structure
and the automatic generation of the necessary common, dimension, equivalence,
and type declarations for each of the user's routines.  the definition
for the common is contained in an easy to modify form, thus
allowing the control of general communications of data between routines.
the described system has been implemented on the ibm 7094,
cdc 6000 series, 
************************

************************
Document:  CACM-2349.html
************************
************************
Document:  CACM-1268.html
************************
************************
Document:  CACM-1104.html
************************
************************
Document:  CACM-1339.html
************************
************************
Document:  CACM-2307.html
************************
************************
Document:  CACM-0185.html
************************
************************
Document:  CACM-1485.html
************************
************************
Document:  CACM-2087.html
************************
************************
Document:  CACM-1971.html
************************
************************
Document:  CACM-0035.html
************************
************************
Document:  CACM-2244.html
************************
************************
Document:  CACM-1614.html
************************
************************
Document:  CACM-1246.html
************************
************************
Document:  CACM-1655.html
************************
************************
Document:  CACM-0263.html
************************
************************
Document:  CACM-2919.html
************************
************************
Document:  CACM-1930.html
************************
************************
Document:  CACM-1847.html
************************


an algorithm for finding a fundamental set of cycles of a graph

a fast method is presented for finding a fundamental
set of cycles for an undirected finite 
graph.  a spanning tree is grown and the vertices examined
in turn, unexamined vertices being stored 
in a pushdown list to await examination.  one stage
in the process is to take the top element v of the 
pushdown list and examine it, i.e. inspect all those
edges (v,z) of the graph for which z has not yet 
been examined.  if z is already in the tree, a fundamental
cycle is added; if not, the edge (v,z) is 
placed in the tree.  there is exactly one such stage
for each of the n vertices of the graph.  for large 
n, the store required in creases as n^2 and the time as
n^g where g depends on the type of graph involved. 
 g is bounded below by 2 and above by 3, and it is shown
that both bounds are attained.  in terms of 
storage our algorithm is similar to that of gotlieb and
corneil and superior to that of welch; in terms 
of speed it is similar to that of welch and superior
to that of gotlieb and corneil.  testsshow our 
algorithm to 
************************

************************
Document:  CACM-1879.html
************************
